\documentclass[11pt,a4paper,oneside]{memoir}

\usepackage[utf8]{inputenc} 
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb,amsthm,amsfonts}
\usepackage{url,color}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{calc}
\usepackage{hyperref}

\geometry{hmargin=2cm,vmargin=2.5cm}

\setcounter{secnumdepth}{10}
\setcounter{tocdepth}{10}


%c'est pour avoir N, Z, Q, R, C
\newcommand{\R}{\mathbb{R}}	\newcommand{\Q}{\mathbb{Q}}	\newcommand{\C}{\mathbb{C}}
\newcommand{\N}{\mathbb{N}}	\newcommand{\Z}{\mathbb{Z}}


\theoremstyle{definition}
\newtheorem{definition}{Définition}

\theoremstyle{remark}
\newtheorem*{remarque*}{{Remarque}}

\theoremstyle{plain}
\newtheorem{proposition}{{Proposition}}
\newtheorem*{proposition*}{{Proposition}}
\newtheorem{theorem}{{Théorème}}



%\title{}
%\author{}
%\date{}


\begin{document}
%\maketitle


% ------------- Page de garde ------------------
\thispagestyle{empty}

\begin{minipage}{.47\textwidth}
\centering
\begin{flushleft}
\includegraphics[scale=0.25]{./Images-Rapport/logo_uvsq.jpeg}
\end{flushleft}
\end{minipage}
\begin{minipage}{.47\textwidth}
\centering
\begin{flushright}
\hspace*{1cm} \includegraphics[scale=0.9]{./Images-Rapport/logo_saclay.jpeg}
\end{flushright}
\end{minipage}


\begin{center}
\huge
\textbf{Master 1\\ Calcul Haute Performance et Simulation}
\end{center}


\begin{center}
  \vspace*{\stretch{3}}
  \hrule
  \hrule
  ~\\
  \begin{center}
    \huge
    \textbf{Rapport de stage}\\
    \bigskip
    \textbf{\'Evaluation de performances via des mini-applications}\\
  \end{center}
  ~\\
  \hrule
  \hrule
\end{center}

\vspace*{\stretch{2}}

\begin{center}
	\Large
	\textsc{\textbf{Stagiaire :}}\\
	\textsc{Robin CAZALBOU}\\
	~ \\
	\textsc{\textbf{Encadrant universitaire :}}\\
	\textsc{Pablo OLIVEIRA}\\
	~ \\
	\textsc{\textbf{Tuteur du Centre Borelli :}}\\
	\textsc{Fikri HAFID}\\
\end{center}

\begin{center}
\includegraphics[scale=0.22]{./Images-Rapport/logo_centre_borelli.png}
\end{center}

\vspace*{\stretch{5}}

\begin{center}
\textsc{\textbf{Année universitaire 2020-2021}}
\end{center}

% ----------------------------------------------





\newpage
\tableofcontents



\begin{vplace}[0.5]

\chapter*{Remerciements}
\addcontentsline{toc}{chapter}{Remerciements}

% texte à écrire ici
% fusionner remerciements et introduction




\chapter*{Introduction}
\addcontentsline{toc}{chapter}{Introduction}

% texte à écrire ici
Ce rapport tient compte des travaux que j'ai réalisé durant mon stage optionnel de fin de master 1 au centre Borelli de l'université Paris Saclay et de l'ENS Paris Saclay. Il fut réalisé sur la période du 17 mai au 28 août 2021, sous la tutelle de M. Fikri HAFID, chercheur au laboratoire du centre Borelli. \bigskip
~\bigskip

% travail en distanciel et en présentiel ?
% ressenti de ce que j'ai pu faire globalement pendant ce stage (premier résumé)

Le cœur de mon travail a consisté en l'étude des mini-applications d'une point de vue Calcul Haute Performance.

% ce que j'ai appris


\end{vplace}







\newpage


\chapter{\'Etat de l'art des mini-applications}

Dans un premier temps, faisons un premier tour d'horizon des mini-applications (que nous appellerons aussi miniapps).

\section{Qu'est ce qu'une miniapp ?}

Une mini-application est définie comme un code de calcul de petite taille (quelques milliers de lignes de code), compilé à partir d'un Makefile simple, cela dans le but de permettre une compréhension plus rapide de l'anatomie interne du code de la part des développeurs \cite{sandia2009}. Ces codes opensource ont pour objectif d'effectuer des simulations simples de problèmes physiques à partir de cœurs d'algorithme de calculs.

Ainsi, la plupart des mini-applications sont obtenues à partir de code de plus grande envergure (par exemple miniXyce, qui simule des circuits électriques, est issue du code Xyce qui comporte plus de 500.000 lignes de codes \cite{sandia2009}). Cependant, contrairement à leur homologue de grande taille, les miniapps n'ont pas pour objectif principal de simuler des problèmes physiques complexes ou inatteignable analytiquement. En effet, la validation des résultats se fait par l'intermédiaire de solutions calculées de façon exacte. L'intérêt sur le résultat à proprement parler est donc infime.

Par ailleurs, les données obtenues après l'exécution du code sont contenues dans des fichiers au format YAML \cite{yaml}, qui possède l'avantage d'être lisible par un humain tout en stockant les informations pour une possible base de données. Des librairies de conception de fichiers au format YAML sont disponibles pour de nombreux langages de programmation.\bigskip

Afin d'être utiles à plusieurs acteurs du monde de la simulation et du Calcul haute performance, ces miniapps se présentent sous la forme simplifiée d'un ou plusieurs \underline{cœurs de calcul numérique}, chacun centré sur une étape clé de l'algorithme global. Par exemple, dans le cas de la mini-application miniFE (pour "mini Finite Elements"), l'étude est centrée sur une méthode des éléments finis, et plus particulièrement sur l'application d'un algorithme de gradient conjugué, qui peut faire l'objet de nombreuses améliorations.

Ces miniapps ont ainsi plusieurs objectifs :
\begin{itemize}
\item permettre aux développeurs HPC et aux numériciens de proposer des méthodes innovantes de communications au sein de l'algorithme, en écartant toutes les données superflues et en permettant une large marge de manœuvre pour effectuer des modifications,
\item permettre d'évaluer les performances d'une architecture de cluster de calcul en considérant la miniapp comme un benchmark simplifié,
\item permettre d'effectuer les modifications du code en conséquences afin de faire concorder matériel et algorithme.
\end{itemize}\bigskip



\section{Présentation de quelques miniapps}

Du fait de la grande diversité des origines des problèmes physiques, ainsi que des approches numériques pour les résoudre, le champs des mini-applications est très vaste. Le Sandia National Laboratories fut un des initiateurs du concept de mini-application et au travers notamment du projet Mantevo \cite{mantevo-project}, de nombreuses miniapps furent conçues. Dans la suite Mantevo 3.0 \cite{heroux2015}, nous pouvons ainsi trouver, entres autres, :
\begin{itemize}
\item \textbf{miniFE} (ou parfois appelée \textbf{HPCCG}) : une mini-application axée sur la résolution d'un système d'équation non-linéaire par la méthode des éléments finis. Le solveur (ou cœur de calcul du code) utilise la méthode du gradient conjugué. Il est écrit en langage C++ et utilise la notion de classe template pour permettre notamment l'étude de l'influence de différents types du C++ permettant le stockage des valeurs (float, double, et leurs variants). Des implémentations hybride MPI+OpenMP, CUDA, OpenCL.
\item \textbf{miniAero} (ajouté à la version 3.0 seulement) : une miniapp de résolution d'équations de Navier-Stokes compressibles, en utilisant des volumes finis au travers d'une méthode de Runge-Kutta d'ordre 4 \cite{miniaero-code}. Le code est écrit en C++.
\item \textbf{TeaLeaf} : écrite en Fortran avec des implémentations OpenMP, MPI et OpenCL, cette miniapp résout l'équation linéaire de la chaleur sur une grille 2D, en utilisant un stencil à 5 points (c'est-à-dire pour lequel chaque cellule mémoire a besoin des données contenues dans les 4 cellules adjacentes). Une version TeaLeaf3D est en développement pour étendre la résolution du problème à un stencil à 7 points. \cite{tealeaf}
\item \textbf{miniGhost} : écrite elle aussi en Fortran et proposant un stencil 5 points, miniGhost étudie notamment plusieurs paradigmes de communications inter-processus en proposant des implémentations sur le modèle BSPMA (Bulk Synchronous Parallel with Message Aggregation), qui consiste à effectuer une phase lourde en communications pendant un intervalle de temps compact, puis à passer à une phase composée uniquement de calculs. D'autres implémentations (SVAF, SVCP) sont proposées et permettent une étude approfondie de ce modèles et de leurs concordances avec l'architecture cible du calculateur \cite{barrett2012}.
\item et bien d'autres (\textbf{miniMD}, \textbf{miniXyce}, \textbf{PathFinder}, \textbf{CoMD}, ...) \cite{heroux2015}
\end{itemize}\bigskip


Afin de pouvoir travailler plus précisément sur le code d'une miniapp en particulier, il m'a fallut faire un choix parmi toutes celles proposées. J'ai écarté celles écrites en Fortran, qui m'auraient demandé un effort supplémentaire dans leur lecture, étant plus familier avec le langage C/C++. Mon choix s'est d'abord penché vers miniAero, dont la segmentation du code permettait une lecture agréable et simplifiée. Cependant l'implémentation proposée par le projet Mantevo \cite{miniaero-code} s'appuyait fortement sur une bibliothèque externe nommée Kokkos, qui exploite un paradigme de programmation du C++ par l'abstraction et l'utilisation massive de templates. Bien que miniAero reste une miniapp du fait que les composantes de Kokkos soient compilées à l'intérieur d'elle, la compréhension de sa structure devenait lourde et aurait impacté les efforts fournis pour comprendre les résultats des mesures effectuées, mais aussi pour éventuellement fournir des améliorations ou modifications du code.\bigskip

J'ai finalement choisi de me concentrer sur la mini-application \textbf{miniXyce}. Cette dernière est un proxy de Xyce, un simulateur de circuit électrique, construit avec un design modulaire et flexible en C++ \cite{about-xyce}. MiniXyce résout les problèmes linéaires non-symétriques qui apparaissent dans des circuits composés d'inducteurs, de résistances et de condensateurs grâce à une généralisation de la méthode de minimisation des résidus (ou GMRES) et une méthode d'Euler implicite \cite{minixyce-code}.

Par ailleurs, suite à la sortie de la version 1.0.0 de miniXyce, les développeurs signalent que sa conception a été axée sur la vérification que les résultats retournés étaient corrects, mais que des "analyses approfondies de Xyce ont montré des problèmes de performance sur trois phases de la simulation : le parsing, le chargement/l'évaluation du device, et la solution des équations linéaires" \cite{minixyce-code}. Ainsi, plusieurs études sont à produire autour de ce code afin de détecter ces failles afin d'éventuellement proposer une amélioration.




\section{\'Etude de miniXyce}

% présenter les différentes approches en détaillées, les quantités qui varient, les architectures qui sont étudiées, les implémentations MPI+OpenMP, etc... cf la biblio




















\begin{vplace}[0.5]

\chapter*{Conclusion}
\addcontentsline{toc}{chapter}{Conclusion}



\end{vplace}







\begin{vplace}
\chapter*{Annexe}
\addcontentsline{toc}{chapter}{Annexe}

% texte à écrire ici

\end{vplace}




\nocite{*}
\bibliographystyle{plain}
\bibliography{Biblio_Stage_Robin_CAZALBOU}

\end{document}